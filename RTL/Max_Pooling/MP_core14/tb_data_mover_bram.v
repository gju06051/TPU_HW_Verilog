// Module Name: tb_data_mover_bram
// 
// description
//      testbench for the Data_Mover_Bram
//      Open test file which is generated by C code. see test.c in SW directory. 
//      C code generate input Node(8 bit) and Weight (8 bit) and Calculate MAC operation. the reulst is in the ref_c_result.txt
//      compare the result by the data_mover and ref_c_result.txt
//
//


`timescale 1ns / 1ps

`define CNT_BIT 31
`define ADDR_WIDTH 10
`define DATA_WIDTH 224
`define DATA_WIDTH_P 112
`define MEM_DEPTH 1024
`define IN_DATA_WIDTH 8
`define NUM_CORE 14 

module tb_data_mover_bram();
    reg                     clk, reset_n;
    reg                     start_run_i;
    reg [`CNT_BIT - 1 : 0]  run_count_i0;
    reg [`CNT_BIT - 1 : 0]  run_count_i1;
    wire                    idle_o;
    wire                    write_o;
    wire                    read_o;
    wire                    done_o;

    /* Memory IF BRAM0 */
    wire [`ADDR_WIDTH - 1 : 0]  addr0_b0;
    wire [`ADDR_WIDTH - 1 : 0]  addr1_b0;
    wire                        ce0_b0;
    wire                        we0_b0;
    wire [`DATA_WIDTH - 1 : 0]  q0_b0;
    wire [`DATA_WIDTH - 1 : 0]  q1_b0;
    wire [`DATA_WIDTH - 1 : 0]  d0_b0;

    /* Memory IF BRAM1 */
    wire [`ADDR_WIDTH - 1 : 0]    addr0_b1;
    wire                          ce0_b1;
    wire                          we0_b1;
    wire [`DATA_WIDTH_P - 1 : 0]  q0_b1;
    wire [`DATA_WIDTH_P - 1 : 0]  d0_b1;

    reg [`IN_DATA_WIDTH - 1 : 0] a_0;
    reg [`IN_DATA_WIDTH - 1 : 0] a_1;
    reg [`IN_DATA_WIDTH - 1 : 0] a_2;
    reg [`IN_DATA_WIDTH - 1 : 0] a_3;
    reg [`IN_DATA_WIDTH - 1 : 0] a_4;
    reg [`IN_DATA_WIDTH - 1 : 0] a_5;
    reg [`IN_DATA_WIDTH - 1 : 0] a_6;
    reg [`IN_DATA_WIDTH - 1 : 0] a_7;
    reg [`IN_DATA_WIDTH - 1 : 0] a_8;
    reg [`IN_DATA_WIDTH - 1 : 0] a_9;
    reg [`IN_DATA_WIDTH - 1 : 0] a_10;
    reg [`IN_DATA_WIDTH - 1 : 0] a_11;
    reg [`IN_DATA_WIDTH - 1 : 0] a_12;
    reg [`IN_DATA_WIDTH - 1 : 0] a_13;
    reg [`IN_DATA_WIDTH - 1 : 0] a_14;
    reg [`IN_DATA_WIDTH - 1 : 0] a_15;
    reg [`IN_DATA_WIDTH - 1 : 0] a_16;
    reg [`IN_DATA_WIDTH - 1 : 0] a_17;
    reg [`IN_DATA_WIDTH - 1 : 0] a_18;
    reg [`IN_DATA_WIDTH - 1 : 0] a_19;
    reg [`IN_DATA_WIDTH - 1 : 0] a_20;
    reg [`IN_DATA_WIDTH - 1 : 0] a_21;
    reg [`IN_DATA_WIDTH - 1 : 0] a_22;
    reg [`IN_DATA_WIDTH - 1 : 0] a_23;
    reg [`IN_DATA_WIDTH - 1 : 0] a_24;
    reg [`IN_DATA_WIDTH - 1 : 0] a_25;
    reg [`IN_DATA_WIDTH - 1 : 0] a_26;
    reg [`IN_DATA_WIDTH - 1 : 0] a_27;

    always begin
        #5 clk = ~clk;
    end

    integer i, f_in_node, f_ot, status;

    initial begin
        // read file open, write file open
        // C:\Users\정기용\Desktop\활동\URP\Code\CNN_HW_PROJ\RTL\Max_Pooling\MP_Code 
        f_in_node = $fopen("C:/FPGA_prj/URP/MAX_Pooling_14/test_file/ref_c_rand_input_node_MP14.txt", "rb");
        f_ot = $fopen("C:/FPGA_prj/URP/MAX_Pooling_14/test_file/ref_c_result_MP_v.txt", "wb");
    end

    initial begin
        // initialize
        reset_n = 1;
        clk     = 0;
        start_run_i = 0;
        run_count_i0 = `MEM_DEPTH;
        run_count_i1 = (`MEM_DEPTH / 2); // 2 * 2 Pooling -> dividied by 2
        

        // reset
        $display("Reset. [%0d]", $time);
        #100    reset_n = 0;
        #10     reset_n = 1;
        #10     @(posedge clk); #1

        // give BRAM to test data
        $display("Mem Write to BRAM0 [%0d]", $time);
        for(i = 0; i < run_count_i0; i = i + 1) begin     
            status = $fscanf(f_in_node, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n", 
                      a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7, a_8, a_9, a_10, a_11, a_12, a_13,
                      a_14, a_15, a_16, a_17, a_18, a_19, a_20, a_21, a_22, a_23, a_24, a_25, a_26, a_27);
            BRAM0_inst.ram[i] = {a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7, a_8, a_9, a_10, a_11, a_12, a_13,
                                 a_14, a_15, a_16, a_17, a_18, a_19, a_20, a_21, a_22, a_23, a_24, a_25, a_26, a_27};
        end

        // Check Idle
        $display("Check IDLE state [%0d]", $time);
        wait(idle_o);

        // start
        $display("Starting DATA_Mover_BRAM [%0d]", $time);
        start_run_i = 1;
        @(posedge clk); #1
        start_run_i = 0;
        
        // wait for done
        $display("Wait for done state [%0d]", $time);
        wait(done_o);

        // $display("Read Result [%0d]", $time);
        // $fwrite(f_ot, "%0d %0d %0d %0d ", result_0, result_1, result_2, result_3, result_4, result_5, result_6);
        $display("Read Result from BRAM1 [%0d]", $time);
        for(i = 0; i < (run_count_i1); i = i + 1) begin // pooling size 2 -> divide by 2
            {a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7, a_8, a_9, a_10, a_11, a_12, a_13} = BRAM1_inst.ram[i];
            $fwrite(f_ot, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d\n", a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7, a_8, a_9, a_10, a_11, a_12, a_13);
        end

        $fclose(f_in_node);
        $fclose(f_ot);
        #100
        $display("Simulation Success.", $time);
        $finish;
    end

    // CALL DUT
    data_mover_bram_Pooling14
    # (
        .CNT_BIT(`CNT_BIT),

        /* parameter for BRAM */
        .DWIDTH(`DATA_WIDTH),
        .DWIDTH_P(`DATA_WIDTH_P),
        .AWIDTH(`ADDR_WIDTH),
        .MEM_SIZE(`MEM_DEPTH),
        .IN_DATA_WIDTH(`IN_DATA_WIDTH)
    ) data_mover_bram_inst (
        /* Special Inputs*/
        .clk(clk),
        .reset_n(reset_n),

        /* Signal From Register */
        .start_run_i(start_run_i), 
        .run_count_i0(run_count_i0), 
        .run_count_i1(run_count_i1),

        /* Memory I/F for BRAM0 */
        .q_b0_i1(q0_b0),
        .q_b0_i2(q1_b0),

        /* Memory I/F for BRAM0 */
        .q_b1_i(q0_b1),

        /* State_Outputs */
        .idle_o(idle_o),
        .read_o(read_o),
        .write_o(write_o),
        .done_o(done_o),

        /* Memory I/F .for BRAM0 */
        .addr0_b0_o(addr0_b0),
        .addr1_b0_o(addr1_b0),
        .ce_b0_o(ce0_b0),
        .we_b0_o(we0_b0),
        .d_b0_o(d0_b0),
    
        /* Memory I/F .for BRAM1 */
        .addr_b1_o(addr0_b1),
        .ce_b1_o(ce0_b1),
        .we_b1_o(we0_b1),
        .d_b1_o(d0_b1)
    );

    true_dpbram
    #(
        .DWIDTH(`DATA_WIDTH),
        .AWIDTH(`ADDR_WIDTH),
        .MEM_SIZE(`MEM_DEPTH)
    ) BRAM0_inst (
        /* Special Inputs */
        .clk(clk),

        /* for port 0 */
        .addr0_i(addr0_b0),
        .ce0_i(ce0_b0),
        .we0_i(we0_b0),
        .d0_i(d0_b0),

        /* for port 1 */
        .addr1_i(addr1_b0),
        .ce1_i(ce0_b0), // sharing with port0
        .we1_i(we0_b0), // sharing
        .d1_i(d0_b0),  // sharing (not used)

        /* output for port 0 */
        .q0_o(q0_b0),
        
        /* output for port 1 */
        .q1_o(q1_b0)
    );

    true_dpbram
    #(
        .DWIDTH(`DATA_WIDTH_P),
        .AWIDTH(`ADDR_WIDTH),
        .MEM_SIZE(`MEM_DEPTH)
    ) BRAM1_inst (
        /* Special Inputs */
        .clk(clk),

        /* for port 0 */
        .addr0_i(addr0_b1),
        .ce0_i(ce0_b1),
        .we0_i(we0_b1),
        .d0_i(d0_b1),

        /* for port 1 */
        .addr1_i(),
        .ce1_i(),
        .we1_i(),
        .d1_i(),

        /* output for port 0 */
        .q0_o(q0_b1),
        
        /* output for port 1 */
        .q1_o()
    );
endmodule